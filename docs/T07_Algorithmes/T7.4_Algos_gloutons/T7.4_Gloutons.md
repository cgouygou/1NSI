# T7.4 Algorithmes gloutons

![](../images/greedy.png){: .center} 

## 7.4.1 Stratégie gloutonne

!!! note "Un problème de remplissage"
    On souhaite remplir un rectangle avec des carrés, avec le nombre minimum de carrés possible.
    === "Rectangle 13 × 8"
        === "Figure"
            ![](../images/rectangle_13x8_0.png){: .center} 
        
        === "SOlution"
            ![](../images/rectangle_13x8_1.png){: .center} 

    
    === "Rectangle 13 × 11"
        === "Figure"
            ![](../images/rectangle_13x11_0.png){: .center} 

        === "Solution"
            ![](../images/rectangle_13x11_1.png){: .center} 


!!! abstract "Algorithme glouton (greedy algorithm)"
    Un algorithme est appelé **glouton** lorsqu'il fait le meilleur choix *local* à chaque étape en espérant obtenir le meilleur choix *global*.

    Autrement dit, lorsqu'on décompose un problème en sous-problèmes, plutôt que de tous les explorer, on ne choisit que celui qui *paraît* optimal.
    
    Si ce choix est toujours correct, on obtiendra bien la solution optimale au
    problème de départ, de manière particulièrement efficace. Si ce choix n’est pas trop mauvais on obtiendra une bonne *approximation* de la solution.
    
    Les algorithmes gloutons peuvent donc être parfois exacts, ou parfois approchés. Mais ils sont généralement extrêmement efficaces.

## 7.4.2 Le problème du rendu de monnaie

Le problème du rendu de monnaie consiste à déterminer comment faire une somme (par exemple 27) avec le **nombre minimum** de pièces et de billets à disposition (par exemple 200, 100, 50, 20, 10, 5, 2, 1).

On peut bien entendu faire 27 = 10 + 10 + 5 + 1 + 1, mais ce n'est pas la solution optimale, qui est bien entendu (?) 27 = 20 + 5 + 2.

!!! gear "Première stratégie: la force brute (bruteforce)"

    On pourrait envisager toutes les façons de décomposer une somme donnée avec les valeurs à disposition. Cette méthode permet à coup sûr de trouver la solution optimale globale au problème, mais le nombre de possibilités augmente très vite (76 décompositions pour 27), et nécessite un temps de calcul trop important.


!!! gear "Stratégie gloutonne"

    === "Vers un algorithme"
        En quoi consiste cette stratégie dans le problème du rendu de monnaie?

        Réfléchir à un algorithme en langage naturel avec des valeurs de pièces décroissantes (et distinctes) qui donne la liste des pièces nécessaires pour une somme donnée en entrée.
    
    === "Algorithme"
        La solution qui suit est celle qu’on emploie intuitivement, à juste titre, avec les systèmes de monnaie en
        vigueur : essayer de faire la somme en prenant d’abord les plus grosses pièces (le cas où on cherche à se
        débarrasser des pièces rouges en achetant du pain n’est pas traité).
        
        **Données:** une liste `pieces` et une `somme`

        **Initialisation:**

        - un entier `i` à 0 (indice de la plus grande pièce) dans la liste `pieces`;
        - une liste vide `monnaie` 

        **Algorithme:**

        - tant que `somme` est strictement positive:
            - si la pièce à l'indice `i` est supérieure à `somme`, ajouter la pièce à `monnaie` et actualiser `somme`
            - sinon incrémenter `i`
        - renvoyer `monnaie`

    === "Implémentation"
        ```python linenums='1' title='Programme à connaître'
        pieces = [200, 100, 50, 20, 10, 5, 2, 1]

        def rendu(somme: int, p: list) -> list:
            i =  0 
            monnaie = []
            while somme > 0:
                if p[i] <= somme :
                    solution.append(p[i])
                    somme = somme - p[i] 
                else :
                    i += 1
            return monnaie
        ```

        `rendu(27, pieces)` doit renvoyer `[20, 5, 2]` .



    === "Une solution optimale ?"
        Que se passe-t-il si le système de monnaie est un peu plus exotique, comme 1, 4, 5, 10 et qu'on souhaite faire 28 ? Ou si des pièces, par exemple 5 et 10, ne sont plus disponibles et qu'on souhaite obtenir 63?

        ??? info "Moralité"
            La stratégie gloutonne ne donne pas systématiquement la solution optimale au problème du rendu de monnaie.
            
            Lorsqu'elle le fait, on dit que le système de monnaie est **canonique**, ce qui est compliqué à déterminer mathématiquement.




## 7.4.3 Le problème du sac à dos